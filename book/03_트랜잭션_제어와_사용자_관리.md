# 03. 트랜잭션 제어 & 사용자 관리

NoSQL로 분류되는 모든 제품이 트랜잭션을 제어할 수 있고 일관성과 공유 기능을 제공하는 것은 아닙니다. 많은 제품들 중에 관계형 DB의 Commit, Rollback 명령어처럼 트랜젝션 제어가 가능한 제품이 몇되지 않은데 그 중 하나가 Redis 입니다. **하지만 관계형 DB 처럼 Commit, Rollback을 수행하게 되면 초딩 100,000 ~ 200,000건 이상 데이터의 쓰기와 읽기 작업에 좋은 성능을 기대할 수는 없게 되는 문제점이 발생하게 되는데 이를 보완하기 위해 Redis는 Read Committed 타입의 트랜잭션 제어 타입도 제공하고 있습니다.**

일반적으로 관계형 DB 또는 대부분의 NoSQL 기술은 아래와 같이 5가지 유형의 락-메커니즘을 제공하는데 Redis 4.0 버전은 데이터-셋 레벨의 락 메커니즘을 제공하고 있습니다.

- Global Lock
- Database Lock
- Object Lock
- Page Lock
- **Key/Value(Data Sets) Lock**



## 3.2 CAS(Check and Set)

```
> WATCH         -> 다중 트랜잭션 모니터링 시작
> MULTI         -> 트랜잭션 시작
OK              
> Set 1 jmjoo   
QUEUED          -> 임시 저장
> Sest 2 yhjoo  
QUEUED          -> 임시 저장
>
> EXEC          -> 트랜잭션 종료
Error ....
```

**하나의 트랜잭션에 의해 데이터가 변경되는 시점에 다른 트랜잭션에 의해 동일한 데이터가 먼저 변경되는 경우 일관성에 문제가 발생할 수 있습니다.** Redis는 이와 같은 경우 `Watch` 명령어에 의해 트랜잭션을 취소할 수 있습니다.

데이터 일관성과 공유(동일한 데이터를 동시 여러 명의 사용자가 수정, 삭제 하는 경우 발생하는 충돌을 피하기 위한 기술)을 위해서 동시 처리가 발생할 때 먼저 **작업을 요구한 사용자에게 우선권을 보장하고 나중에 작업을 요구한 사용자의 세션에서는 해당 트랜잭션에 충돌이 발생했음을 인지할 수 있도록 해야하는데 이를 Redis DB에서는 CAS 라고 합니다.**



### 실습

```bash
redis> WATCH a # 다중 트랜잭션이 발생하는지 여부를 모니터링 시작함
OK
redis> MULTI # 트랜잭션 시작
OK
redis(TX)> Set 1 jmjoo
QUEUED # 임시 저장
redis(TX)> Set 2 yhjoo
QUEUED # 임시 저장
redis(TX)> EXEC # 트랜잭션 종료
1) OK
2) OK
```



## 3.3 commit & rollback

Redis 서버에서 트랜잭션을 사용자가 직접 제어하는 방법입니다. 변경한 데이터를 최종 저장할 때 EXEC, 취소할 때 DISCARD 명령어를 실행합니다.

**실습**

```bash
redis> WATCH a
OK
redis> MULTI
OK
redis(TX)> Set 1 jmjoo
QUEUED
redis(TX)> Set 2 yhjoo
QUEUED
redis(TX)> EXEC # 트랜잭션 Commit
1) OK
2) OK

redis> FLUSHALL # 데이터 초기화
redis> MULTI
OK
redis> Set 3 jmjoo
QUEUED
redis> Set 4 yhjoo
QUEUED
redis> DISCARD # 트랜잭션 Rollback
OK
redis> keys *
(empty array)
```



## 3.4 Index 유형 및 생성

Redis DB는 기본적으로 하나의 Key와 하나 이상의 Field/Element 값으로 구성되는데 **해당 Key에 빠른 검색을 위해 기본적으로 인덱스가 생성됩니다. 이를 Primary Key Index라고 합니다. 또한 사용자의 필요에 따라 추가적인 인덱스를 생성할 수 있는데 이를 Secondary Index라고 합니다.**

인덱스 키를 통해 검색할 때 유일한 값을 검색하는 경우에 `Exact Match By a Secondary Index`라고 하며 일정 범위의 값을 검색 조건으로 부여하는 경우를 `Range By Secondary Index` 라고합니다.



**실습**

Sorted Set 타입 인덱스

```bash
redis> ZADD order.ship_date.index 2 '201809124:20180926'
(integer) 1

# order 테이블, order_no:ship_date 필드에 인덱스 생성
redis> ZADD order.ship_date.index 1 '201809123:20180925'
(integer) 1

redis> ZRANGE order.ship_date.index 0 -1
1) "201809123:20180925"
2) "201809124:20180926"

redis> ZSCAN order.ship_date.index 0
1) "0"
2) 1) "201809123:20180925"
   2) "2"
   3) "201809124:20180926"
   4) "2"
```



## 3.5 사용자 생성 및 인증/보안/Roles

### Access Control 권한

- DBMS의 가장 보편적인 인증 방식으로 미리 사용자 계정과 암호를 생성한뒤 이 계정명과 암호를 정확히 입력하면 사용자를 이증하는 방식 ex `vi redis.config`, `requirepass manager`
- Redis에 접속할때 Access Control을 선탳갛ㄹ 수 있습니다. `vi config`, `masterauth redis123`

### OS 인증 & Internal 인증

- Redis에서는 해당 시스템의 IP-Address로만 접속을 허용하는 Network 인증 방식을 제공합니다. `vi redis.conf`, `bind_ip 192,168.0.10`
- Auth command를 이용하여 인증하는 방법입니다. `auth manager`